#!/bin/bash
set -eu

function sanitize-filename {
  local filename=$1
  filename=${filename//$'\0'/ }
  filename=${filename//$'\n'/ }
  filename=${filename//\\/＼}
  filename=${filename//\//∕}
  filename=${filename//:/꞉}
  filename=${filename//\*/∗}
  filename=${filename//\"/‟}
  filename=${filename//</＜}
  filename=${filename//>/＞}
  filename=${filename//|/❘}
  filename=${filename//\?/？}

  sed -f - <(echo "$filename") << \EOF
s/\s\+/ /g
s/^\s*//
s/\s*$//
EOF
}

function copy-article {
  rsync -ahsz --progress "$@"
}

articles_path=articles

function list-articles {
  ssh personal ls "$articles_path"
}

function download-articles {
  local path=/media/$USER/Kindle
  local filename
  while IFS= read -r filename; do
    local article_path=$articles_path/$filename
    local sanitized_filename=$(sanitize-filename "${filename%.*}")
    copy-article personal:"$article_path" "$path"/documents/"$articles_path"/"$sanitized_filename".pdf
    ssh personal xargs -d '\\n' rm <<< "$article_path"
  done < <(list-articles)
}

function install-packages {
  local packages=(
    chromium
    libimage-exiftool-perl
    poppler-utils
  )
  dpkg -s "${packages[@]}" &> /dev/null || sudo apt -y install "${packages[@]}"
}

function parse-options {
  while getopts c:dej:ps: option; do
    if [[ $option == c ]]; then
      style=$OPTARG
    elif [[ $option == d ]]; then
      styles_disabled=true
    elif [[ $option == e ]]; then
      javascript_enabled=true
    elif [[ $option == j ]]; then
      script=$OPTARG
    elif [[ $option == p ]]; then
      print_media=true
    elif [[ $option == s ]]; then
      scale=$OPTARG
    else
      return 1
    fi
  done
}

function rewrite-url {
  local url=$1
  if [[ $url == https://habr.com/* ]]; then
    echo "${url/\/\////m.}"
  else
    echo "$url"
  fi
}

function output-path {
  local directory=~/.cache/${0##*/}
  mkdir -p "$directory"

  find "$directory" -type f -mtime +1 -delete

  local url=$1
  local checksum=$(md5sum <<< "$url")
  echo "$directory"/"${checksum%% *}".pdf
}

function extract-pdf-title {
  local path=$1
  pdfinfo "$path" | grep '^Title:' | sed 's/^[^:]*:\s*\(.*\)\s*$/\1/'
}

function extract-filename {
  local url=$1
  local filename=${url##*/}
  filename=${filename%\?*}
  filename=${filename//%20/ }
  echo "$filename"
}

function process-pdf {
  local url=$1
  local path=$2
  wget -O "$path" "$url"

  local title=$(extract-pdf-title "$path")
  if [[ ! $title ]]; then
    local filename=$(extract-filename "$url")
    title=${filename%.pdf}
  fi
  echo "$title"
}

function install-puppeteer {
  local package=puppeteer-core
  local version=7.1.0
  grep -qs "\"$version\"" "$NPM_CONFIG_PREFIX"/lib/node_modules/"$package"/package.json || npm install -g "$package"@"$version" >&2
}

function extract-host {
  local url=$1
  local host=${url#*://}
  host=${host%%/*}

  [[ $host != *.medium.com ]] || host=${host#*.}

  echo "$host"
}

declare -A javascript_enabled_hosts=(
  [m.habr.com]=true
  [www.theatlantic.com]=true
)

declare -A print_media_hosts=()

declare -A host_scales=()

declare -A host_scripts=()

declare -A host_styles=(
  [m.habr.com]='.spoiler_text { display: block; opacity: 1 }'
  [medium.com]='#root > div > :nth-child(2) { display: none }'
)

declare -A styles_disabled_hosts=()

function process-html {
  install-puppeteer

  local url=$1
  echo -n "Processing $url..." >&2

  local host=$(extract-host "$url")
  NODE_PATH="$NPM_CONFIG_PREFIX"/lib/node_modules \
  javascript_enabled=${javascript_enabled-${javascript_enabled_hosts[$host]-}} \
  print_media=${print_media-${print_media_hosts[$host]-}} \
  scale=${scale-${host_scales[$host]-1.375}} \
  script=${script-${host_scripts[$host]-}} \
  style=${style-${host_styles[$host]-}} \
  styles_disabled=${styles_disabled-${styles_disabled_hosts[$host]-}} \
  local path=$2
  node - "$url" "$path" << \EOF
const puppeteer = require("puppeteer-core");

(async () => {
  try {
    const scale = Number(process.env.scale);
    const width = 560;
    const browser = await puppeteer.launch({
      defaultViewport: {
        deviceScaleFactor: scale,
        height: 100000,
        width,
      },
      executablePath: "chromium",
    });

    const page = await browser.newPage();
    await page.emulateMediaType(process.env.print_media ? "print" : "screen");
    await page.setUserAgent(
      "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.75 Mobile Safari/537.36"
    );

    const javaScriptEnabled = Boolean(
      process.env.javascript_enabled ||
        process.env.style ||
        process.env.styles_disabled
    );
    await page.setJavaScriptEnabled(javaScriptEnabled);

    await page.goto(process.argv[2], { timeout: 60000 });

    await page.evaluate(
      (script, stylesDisabled) => {
        [...document.querySelectorAll("*")].forEach((element) => {
          const style = getComputedStyle(element);
          if (["fixed", "sticky"].includes(style.position)) {
            element.setAttribute("style", "display: none !important");
          }
          if (style.overflow === "auto") {
            element.style.overflow = "visible";
          }
          if (style.whiteSpace === "pre") {
            element.style.whiteSpace = "pre-wrap";
          }
        });

        eval(script);

        if (stylesDisabled) {
          const elements = document.querySelectorAll(
            'link[rel="stylesheet"], style'
          );
          for (element of elements) {
            element.remove();
          }
        }
      },
      process.env.script,
      process.env.styles_disabled
    );

    if (javaScriptEnabled) {
      await page.addStyleTag({
        content: `
        table { border: 1px solid black }
        td, th, tr { border: none }
        td, th { display: block }
        td:not(:last-child), th:not(:last-child) { border-bottom: 1px solid lightgrey }
        tr:not(:last-child) { border-bottom: 1px solid black }
        ${process.env.style}
        ${
          process.env.styles_disabled && "body { font: 1.5em / 1.5 sans-serif }"
        }
        `.replace(/;| }/g, " !important$&"),
      });
    }

    await page.pdf({
      height: 735,
      path: process.argv[3],
      printBackground: true,
      scale,
      width,
    });

    console.log(await page.title());

    await browser.close();
  } catch (error) {
    console.error();
    console.error(error);
    process.exit(1);
  }
})();
EOF

  echo >&2
}

function deactivate-links {
  local string='/S /URI'
  local path=$1
  sed -i "s|$string\b|$(printf "%${#string}s")|g" "$path"
}

function confirm-upload {
  local path=$1
  read -p "Upload '$path'? [Y/n] "
  [[ $REPLY =~ ^[Yy]*$ ]]
}

function truncate-filename {
  local filename=$1
  while (($(wc -c <<< "$filename") > 255)); do
    local suffix=.${filename##*.}
    filename=${filename::-$((${#suffix} + 1))}$suffix
  done
  echo "$filename"
}

function upload-article {
  local title=$2
  local filename=$(truncate-filename "${title//\//∕}".pdf)
  if list-articles | grep -Fqx "$filename"; then
    echo "'$filename' already exists." >&2
    return 1
  fi

  local path=$1
  copy-article "$path" personal:"$articles_path"/"$filename"
}

function process-url {
  local url=$1
  set -- "$(rewrite-url "$url")"

  local path=$(output-path "$url")

  if [[ ${url%\?*} == *.pdf ]]; then
    local title=$(process-pdf "$url" "$path")
  else
    local title=$(process-html "$url" "$path")
  fi

  [[ -f $path ]]

  deactivate-links "$path"
  exiftool -q -overwrite_original -Author="$url" "$path"

  setsid xdg-open "$path" &> /dev/null &

  ! confirm-upload "$title" || upload-article "$path" "$title"
  rm "$path"
}

function main {
  if [[ ! $@ ]]; then
    download-articles
    return
  fi

  install-packages

  parse-options "$@"
  shift "$((OPTIND - 1))"

  local url
  for url; do
    process-url "$url"
  done
}

[[ -v BASH_SOURCE[0] && ${BASH_SOURCE[0]##*/} != ${0##*/} ]] || main "$@"
